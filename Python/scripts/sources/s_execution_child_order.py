#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.4'
#       jupytext_version: 1.1.4
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# # s_execution_child_order [<img src="https://www.arpm.co/lab/icons/icon_permalink.png" width=30 height=30 style="display: inline;">](https://www.arpm.co/lab/redirect.php?code=s_execution_child_order&codeLang=Python)
# For details, see [here](https://www.arpm.co/lab/redirect.php?permalink=FirstOrderChild).

# +
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from arpym.tools.logo import add_logo
# -

# ## [Input parameters](https://www.arpm.co/lab/redirect.php?permalink=s_execution_child_order-parameters)

e_delta_q = 0.3  # expected volume time within delta_t

# ## [Step 0](https://www.arpm.co/lab/redirect.php?permalink=s_execution_child_order-implementation-step00): Load data

# +
# generated by script s_execution_opt_satisfaction_quantile
path = '~/databases/temporary-databases/'
db = pd.read_csv(path + 'db_execution_opt_satisfaction_quantile.csv',
                 index_col=0)

k_ = int(np.array(db['k_'].iloc[0]))
l_ = int(np.array(db['l_'].iloc[0]))
h_q_now = int(np.array(db['h_q_now'].iloc[0]))
h_q_end = int(np.array(db['h_q_end'].iloc[0]))
lam = np.array(db['lam'].iloc[:l_]).reshape(-1)
lambda_star = np.array(db['lambda_star'].iloc[:1]).reshape(-1)
q_grid = np.array(db['q_grid'].iloc[:k_]).reshape(-1)
traj = np.array(db['traj'].iloc[:k_*l_]).reshape((k_, l_))

h_star = traj[:, lam == lambda_star].flatten()
# -

# ## [Step 1](https://www.arpm.co/lab/redirect.php?permalink=s_execution_child_order-implementation-step01): Compute the first child order

# # find optimal schedule value
h_star_e_delta_q = h_star[q_grid == e_delta_q]
# compute first child order
deltah_child = np.round(h_star_e_delta_q - h_q_now)

# ## Plots

# +
plt.style.use('arpm')

fig = plt.figure()
# Optimal trajectory
plt.plot(q_grid, h_star, color='k', lw=1.2)
plt.ylim([h_q_end - 2, h_q_now + 2])
plt.xlabel('Time')
plt.ylabel('Holdings')

# Highlight the first child order size
plt.plot([0, 0.3], [h_q_end - 2, h_q_end - 2], color='b', lw=3)
plt.plot([0, 0], [h_star_e_delta_q, 100], color='r', lw=3)
plt.plot([0, 0.3], np.r_[h_star_e_delta_q, h_star_e_delta_q], color='k',
         linestyle='--')
plt.plot([0.3, 0.3], [0, h_star_e_delta_q], color='k', linestyle='--')
plt.legend(['Optimal trajectory in the Almgren-Chriss model $\lambda$*=% 2.2f'
            % lambda_star,
            'Expected (volume) time of execution of the first child order',
            'Size of the first child order'])
plt.plot(0.3, h_star_e_delta_q, 'o', markeredgecolor='k', markerfacecolor='k')
add_logo(fig)
